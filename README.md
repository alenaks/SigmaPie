# Python package for subregular language processing

In this repository, you can find a package for subregular language processing.
Please find below brief instruction on what is consists of (for now), and how to use it.
In order to get access to the language classes and methods defined for them, please run the following commands in the terminal after downloading the folder `slp`.
Please ensure that you are running `Python3`, no earlier than the version 3.6.

```python3
$ cd ~/slp
$ python3
>>> from main import *
```

## Tools for strictly local (SL) languages
SL languages are generated by SL grammars.
The core idea behind SL grammars is to allow or to prohibit substrings up to a certain length in the generated language.
Grammars that prohibit illicit substrings are *negative*, and the ones that list allowed substrings are *positive*.

Initialize positive or negative SL grammar:

```python3
    >>> posSL = PosSL()
    >>> negSL = NegSL()
```

Initialize the grammar, data, edge symbols in use, or k-gram length:

```python3
    >>> posSL.grammar = [">a", "ab", "ba", "b<"]
    >>> posSL.data = ["ab", "ababab"]
    >>> posSL.edges = [">", "<"]
    >>> posSL.k = 2
```

### Extract grammar given the data
In order to automatically extract the grammar, one needs data of the language.
For this purpose, the user can use `learn` method provided for SL classes.

```python3
    >>> posSL.data = ["ab", "ababab"]
    >>> posSL.learn()
    >>> posSL.grammar
    [('>', 'a'), ('a', 'b'), ('b', '<'), ('b', 'a')] 
```

### Generating a data sample
Method `generate_sample` generates a data sample.
By default, it generates 10 words and does not avoids repetitions, but these specifications can be changed.

Arguments:
* n:int = 10 (number of words to be generated)
* rep:bool = True (generating with or without repetitions)

```python3
    >>> posSL.grammar = [('>', 'a'), ('a', 'b'), ('b', '<'), ('b', 'a')] 
    >>> posSL.generate_sample(n=5, rep=False)
    >>> posSL.data_sample
    ['>ababab<', '>abab<', '>ab<', '>abababab<', '>abababababab<']
```

### Scanning a word
For a given word, tells whether it might or might not be generated by the given grammar.

```python3
    >>> posSL.grammar = [('>', 'a'), ('a', 'b'), ('b', '<'), ('b', 'a')] 
    >>> posSL.scan("aba")
    False
    >>> posSL.scan("abab")
    True
```

### Cleaning the grammar
If the given grammar has useless ngrams, the `clean` method is able to detect and remove them.

```python3
    >>> posSL.grammar = [(">", "a"), ("a", "b"), ("b", "a"), ("b", "<"), (">", "c"), ("c", "d"), ("e", "f"), ("f", "<")]
    >>> posSL.clean()
    >>> posSL.grammar
    [('b', '<'), ('a', 'b'), ('>', 'a'), ('b', 'a')]
```

### Changing polarity of the grammar
If the polarity of the grammar needs to be changed (positive to negative, or vice versa), one can use the method `change_polarity`.
It changes the grammar and the class of the grammar.

```python3
    >>> posSL.grammar = [('>', 'a'), ('a', 'b'), ('b', '<'), ('b', 'a')] 
    >>> negSL = posSL
    >>> negSL.change_polarity()
    >>> negSL.grammar
    [('b', 'b'), ('a', 'a'), ('a', '<'), ('>', '<'), ('>', 'b')]
```


## Tools for tier-based strictly local (TSL) languages 
TSL languages are generated by TSL grammars.
For this type of languages, the notion of a *tier* is crucial.
For every word, its tier consists of an image of this word under the erasing function, when all symbols in this word that are not included in the tier alphabet are being erased.
This approach allows to view long-distance processes as local by ignoring all the intervening material.

Initialize positive TSL grammar:

```python3
    posTSL = PosTSL()
```
**Warning: to be implemented.**

### Author
[Alëna Aksënova](https://www.aaksenova.com/)
