#!/bin/python3

"""
   A class of Strictly Local Grammars.
   Copyright (C) 2017  Alena Aksenova
   
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.
"""

from typing import TypeVar, Union, Tuple, List
from random import choice
from helper import *
from fsm import *
from grammar import *

PosStL = TypeVar('PosStL', bound='PosSL')
NegStL = TypeVar('NegStL', bound='NegSL')

class PosSL(PosGram):
    """ A class for positive strictly local grammars.

    Attributes:
    -- alphabet: the list of symbols used in the given language;
    -- grammar: the list of grammatical rules;
    -- k: the locality measure;
    -- data: the language data given as input;
    -- data_sample: the generated data sample;
    -- fsm: the finite state machine that corresponds to the given grammar.
    """

    def __init__(self:PosG, alphabet:Union[None,list]=None, grammar:Union[None,List[tuple]]=None, k:int=2,
                 data:Union[list,None]=None, edges=[">", "<"]) -> None:
        """ Initializes the PosSL object. """
        
        super().__init__(alphabet, grammar, k, data, edges)
        self.fsm = FiniteStateMachine()


    def learn(self:PosStL) -> None:
        """
        Extracts positive SL grammar from the given data.

        Arguments:
        -- self.

        Results:
        -- self.grammar is being detected.
        """

        if self.data:
            self.grammar = self.ngramize_data(self.k, self.data)
            self.extract_alphabet()


    def generate_sample(self:PosStL, n:int=10, rep:bool=True) -> None:
        """
        Generates a sample of the data of a given size.

        Arguments:
        -- self;
        -- n (optional): the number of examples, the default value is 10;
        -- rep (optional): allow (rep=True) or prohibit (rep=False)
               repetitions, the default value is True.

        Results:
        -- self.data_sample is being generated.

        """
        
        self.fsmize()
        self.extract_alphabet()

        data = [self.generate_item() for i in range(n)]
        self.data_sample = data

        if rep == False:
            self.data_sample = list(set(self.data_sample))
            while len(self.data_sample) < n:
                self.data_sample += [self.generate_item()]
                self.data_sample = list(set(self.data_sample))


    def scan(self:PosStL, string:str) -> bool:
        """
        Checks whether the given string can be generated by the grammar.

        Arguments:
        -- self;
        -- string: the string that needs to be evaluated.

        Returns:
        -- a boolean value depending on the well-formedness of the string
           with respect to the given grammar.
        """
        
        if not self.grammar:
            self.learn()

        string = self.annotate_data(string, self.k)
        if set(self.ngramize_item(string, self.k)).issubset(set(self.grammar)):
            return True
        else:
            return False


    def clean(self:PosStL) -> None:
        """
        Removes useless n-grams from the grammar. Useless ngrams are
        that can never be used in the language.

        Arguments:
        -- self.

        Results:
        -- self.fsm contains the FSM of the current grammar;
        -- self.grammar is being cleaned.
        """

        self.fsmize()
        self.fsm.trim_fsm()
        self.grammar = self.build_ngrams(self.fsm.transitions)


    def change_polarity(self:PosStL) -> None:
        """
        Changes polarity of the grammar.

        Arguments:
        -- self.

        Results:
        -- self.grammar is being switched to the opposite;
        -- self.__class__ is changed to 'NegSL'.
        """

        if not self.alphabet:
            self.extract_alphabet()
        self.grammar = self.opposite_polarity(self.grammar, self.alphabet, self.k)
        self.__class__ = NegSL


    def generate_item(self:PosStL) -> str:
        """
        Generates a well-formed sequence of symbols.

        Arguments:
        -- self.

        Returns:
        -- a well-formed sequence with respect to a given grammar.
        """
        
        smap = self.state_map()
        if any([len(smap[x]) for x in smap]) == 0:
            raise(ValueError("The grammar is not provided properly."))

        word = self.edges[0]
        while word[-1] != self.edges[1]:
            word += choice(smap[word[-1]])

        return word


    def state_map(self:PosStL) -> dict:
        """ Generates a dictionary of possible transitions in the given FSM.

        Arguments:
        -- self.

        Returns:
        -- the dictionary of the form {symbol:[list of possible transitions]}.
        """
            
        smap:dict = {}
        smap[self.edges[0]] = [i[1] for i in self.fsm.transitions if i[0] == (self.edges[0],)]
        for symb in self.alphabet:
            smap[symb] = [i[1] for i in self.fsm.transitions if i[0] == (symb,)]

        return smap

        
    def fsmize(self:PosStL) -> None:
        """
        Function that builds FSM corresponding to the given grammar.

        Arguments:
        -- self.

        Results:
        -- self.fsm contains a finite states machine that corresponds to
                    the given grammar.
        """
        
        if self.grammar:
            self.fsm.sl_states(self.grammar)
        else:
            raise(IndexError("The grammar is not provided."))


    def annotate_data(self:PosStL, data:str, k:int) -> str:
        """ Annotates the data with the start-/end-symbols. """
        
        return ">"*(k-1) + data.strip() + "<"*(k-1)
        

    def ngramize_data(self:PosStL, k:int, data:list) -> list:
        """
        Creates set of k-grams out of the given data.

        Arguments:
        -- self;
        -- k: the locality measure;
        -- data: the data given as input.

        Returns:
        -- the list of ngrams based on the given data.
        """
        
        grammar:list = []
        for s in data:
            item = self.annotate_data(s, k)
            grammar += self.ngramize_item(item, k)

        return list(set(grammar))


    def ngramize_item(self:PosStL, item:str, k:int) -> list:
        """ This function n-gramizes a given string. """

        ngrams:list = []
        for i in range(len(item)-(k-1)):
            ngrams += [tuple(item[i:i+k])]
                
        return list(set(ngrams))


    def build_ngrams(self:PosStL, transitions:list) -> list:
        """
        Generates SL grammar based on the given transitions. For example,
        for the transition ("ab", "c", "bc") it gives ngram "abc".

        Arguments:
        -- self;
        -- transitions: the list of transitions of the fsm.

        Returns:
        -- the list of ngrams built based on those transitions.
        """
        
        if transitions == []:
            return transitions

        ngrams:list = []
        for i in transitions:
            ngrams.append(i[0] + (i[1],))

        return ngrams


class NegSL(PosSL):
    """ A class for negative strictly local grammars.

    Attributes:
    -- alphabet: the list of symbols used in the given language;
    -- grammar: the list of grammatical rules;
    -- k: the locality measure;
    -- data: the language data given as input;
    -- data_sample: the generated data sample;
    -- fsm: the finite state machine that corresponds to the given grammar.
    """

    def learn(self:NegStL) -> None:
        """
        Extracts positive SL grammar from the given data.

        Arguments:
        -- self.

        Results:
        -- self.grammar is being detected.
        """

        self.extract_alphabet()
        super().learn()
        self.grammar = self.opposite_polarity(self.grammar, self.alphabet, self.k)


    def scan(self:NegStL, string:str) -> bool:
        """
        Checks whether the given string can be generated by the grammar.

        Arguments:
        -- self;
        -- string: the string that needs to be evaluated.

        Returns:
        -- a boolean value depending on the well-formedness of the string
           with respect to the given grammar.
        """

        if not self.grammar:
            self.learn()

        if not set(alphabetize(string)).issubset(set(self.alphabet)):
            return False
        string = self.annotate_data(string, self.k)
        ngramized_string = self.ngramize_item(string, self.k)
        for i in ngramized_string:
            if i in self.grammar:
                return False
        return True
    

    def clean(self:NegStL) -> None:
        """
        Removes useless n-grams from the grammar. Useless ngrams are
        that can never be used in the language.

        Arguments:
        -- self.

        Results:
        -- self.fsm contains the FSM of the current grammar;
        -- self.grammar is being cleaned.
        """

        super().clean()
        self.grammar = self.opposite_polarity(self.grammar, self.alphabet, self.k)


    def fsmize(self:NegStL) -> None:
        """
        Function that builds FSM corresponding to the given grammar.

        Arguments:
        -- self.

        Results:
        -- self.fsm contains a finite states machine that corresponds to
                    the given grammar.
        """

        self.extract_alphabet()
        self.grammar = self.opposite_polarity(self.grammar, self.alphabet, self.k)
        super().fsmize()
        self.grammar = self.opposite_polarity(self.grammar, self.alphabet, self.k)

        
    def change_polarity(self:NegStL) -> None:
        """
        Changes polarity of the grammar.

        Arguments:
        -- self.

        Results:
        -- self.grammar is being switched to the opposite;
        -- self.__class__ is changed to 'PosSL'.
        """

        self.extract_alphabet()
        self.grammar = self.opposite_polarity(self.grammar, self.alphabet, self.k)
        self.__class__ = PosSL
