#!/bin/python3

"""
   A class of Tier-based Strictly Local Grammars.
   Copyright (C) 2017  Alena Aksenova
   
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.
"""

from typing import TypeVar, Generator, Union
from random import choice, randint
from sl_class import *

PTSL = TypeVar('PTSL', bound='PosTSL')
NTSL = TypeVar('NTSL', bound='NegTSL')

class PosTSL(PosSL):
    """ A class for positive strictly local grammars.

    Attributes:
    -- alphabet: the list of symbols used in the given language;
    -- grammar: the list of grammatical rules;
    -- k: the locality measure;
    -- data: the language data given as input;
    -- data_sample: the generated data sample;
    -- fsm: the finite state machine that corresponds to the given grammar;
    -- tier: the list of tier symbols.
    """
    
    def __init__(self:PTSL, alphabet:Union[None,list]=None, grammar:Union[None,List[tuple]]=None, k:int=2,
                 data:Union[list,None]=None, edges=[">", "<"], tier:Union[None,list]=None) -> None:
        """ Initializes the PosTSL object. """
        
        super().__init__(alphabet, grammar, k, data, edges)
        self.tier = tier


    def learn(self:PTSL) -> None:
        """
        Extracts positive TSL grammar from the given data.

        Arguments:
        -- self.

        Results:
        -- self.grammar is being detected.
        """

        self.learn_tier()
        tier_sequences = self.erasing_function()
        
        if tier_sequences:
            self.grammar = self.ngramize_data(self.k, tier_sequences)
            self.fsmize()


    def generate_sample(self:PTSL, n:int=10, rep:bool=True) -> None:
        """
        Generates a sample of the data of a given size.

        Arguments:
        -- self;
        -- n (optional): the number of examples, the default value is 10;
        -- rep (optional): allow (rep=True) or prohibit (rep=False)
               repetitions, the default value is True.

        Results:
        -- self.data_sample is being generated.

        """

        super().generate_sample(n, rep)


    def generate_item(self:PTSL) -> str:
        """
        Generates a well-formed sequence of symbols.

        Arguments:
        -- self.

        Returns:
        -- a well-formed sequence with respect to a given grammar.
        """

        tier_seq = super().generate_item()
        ind = [x for x in range(len(tier_seq)) if tier_seq[x] not in self.edges]
        tier_items = list(tier_seq[ind[0]:(ind[-1]+1)])
        free_symb = list(set(self.alphabet).difference(set(self.tier)))
        
        new_string = self.edges[0]*(self.k-1)
        for i in range(self.k+1):
            if randint(0,1) == 1:
                new_string += choice(free_symb)

        if tier_items:
            for item in tier_items:
                new_string += item
                for i in range(self.k+1):
                    if randint(0,1) == 1:
                        new_string += choice(free_symb)

        new_string += self.edges[1]*(self.k-1)
        
        return new_string


    def state_map(self:PTSL) -> dict:
        """ Generates a dictionary of possible transitions in the given FSM.

        Arguments:
        -- self.

        Returns:
        -- the dictionary of the form
            {"previous_symbols":[list of possible next symbols]}.
        """
            
        smap:dict = {}
        local_alphabet = self.tier[:] + self.edges[:]
        poss = product(local_alphabet, repeat=self.k-1)
        for i in poss:
            for j in self.fsm.transitions:
                if j[0] == i:
                    before = "".join(i)
                    if before in smap:
                        smap[before] += j[1]
                    else:
                        smap[before] = [j[1]]
        return smap


    def learn_tier(self:PTSL) -> None:
        """
        This function determines which of the symbols used in the language
        are tier symbols. The learner is taken from Jardine & McMullin (2016).

        Arguments:
        -- self.

        Results:
        -- self.tier contains the list of the tier symbols.
        """
        
        self.extract_alphabet()
        self.tier = self.alphabet[:]

        if self.tier:
            ngrams = self.ngramize_data(self.k, self.data)
            ngrams_less = self.ngramize_data(self.k-1, self.data)
            ngrams_more = self.ngramize_data(self.k+1, self.data)

            for symbol in self.tier:
                if self.test_insert(symbol, ngrams, ngrams_less) and \
                   self.test_remove(symbol, ngrams, ngrams_more):
                    self.tier.remove(symbol)


    def scan(self:PTSL, string:str) -> bool:
        """
        Checks whether the given string can be generated by the grammar.

        Arguments:
        -- self;
        -- string: the string that needs to be evaluated.

        Returns:
        -- a boolean value depending on the well-formedness of the string
           with respect to the given grammar.
        """

        if not set(alphabetize([string])).issubset(set(self.alphabet)):
            return False
        tier_img = self.annotate_data(self.tier_image(string, self.tier), self.k)
        if set(self.ngramize_item(tier_img, self.k)).issubset(set(self.grammar)):
            return True
        else:
            return False


    def test_insert(self:PTSL, symbol:str, ngrams:list, ngrams_less:list) -> bool:
        """
        Tier presense test #1. For every (n-1)-gram of the type 'xy',
        there must be an n-gram of the type 'xSy'.

        Arguments:
        -- self;
        -- symbol: the symbol that is currently being tested;
        -- ngrams: the list of ngrams;
        -- ngrams_less: the list of (n-1)-grams.

        Returns:
        -- a boolean value depending on whether the symbol passed
           the test or not.
        """

        extension = []
        for small in ngrams_less:
            for i in range(len(small)):
                new = small[:i] + (symbol,) + small[i:]
                if self.good_ngram(new):
                    extension.append(new)
                    
        if set(extension).issubset(set(ngrams)):
            return True
        else:
            return False


    def test_remove(self:PTSL, symbol:str, ngrams:list, ngrams_more:list) -> bool:
        """
        Tier presense test #2. For every (n+1)-gram of the type 'xSy',
        there must be an n-gram of the type 'xy'.

        Arguments:
        -- self;
        -- symbol: the symbol that is currently being tested;
        -- ngrams: the list of ngrams;
        -- ngrams_more: the list of (n+1)-grams.

        Returns:
        -- a boolean value depending on whether the symbol passed
           the test or not.
        """
        
        extension = []
        for big in ngrams_more:
            if symbol in big:
                for i in range(len(big)):
                    if big[i] == symbol:
                        new = big[:i] + big[i+1:]
                        if self.good_ngram(new):
                            extension.append(new)

        if set(extension).issubset(set(ngrams)):
            return True
        else:
            return False
                

    def erasing_function(self:PTSL) -> list:
        """
        Function that erases non-tier symbols from the data attribute
        therefore leaving just tier sequences.

        Arguments:
        -- self.

        Returns:
        -- a list of data under the erasing image.
        """
        
        erased = []
        if self.data:
            for item in self.data:
                erased.append(self.tier_image(item, self.tier))
            return list(set(erased))
        else:
            return []


    def tier_image(self:PTSL, string:str, tier:list) -> str:
        """
        Function that shows a tier image of the string given as input.

        Arguments:
        -- self;
        -- string: the string tier image of which is required;
        -- tier: the list of tier symbols.

        Returns:
        -- a tier image of the given string.
        """
        
        new = ""
        for i in string:
            if i in tier:
                new += i
        return new

    

    def change_polarity(self:PTSL) -> None:
        """
        Changes polarity of the grammar.

        Arguments:
        -- self.

        Results:
        -- self.grammar is being switched to the opposite;
        -- self.__class__ is changed to 'NTSL'.
        """

        if not self.tier:
            self.learn()
        self.grammar = self.opposite_polarity(self.grammar, self.tier, self.k)
        self.__class__ = NegTSL


class NegTSL(PosTSL):
    """ A class for negative strictly local grammars.

    Attributes:
    -- alphabet: the list of symbols used in the given language;
    -- grammar: the list of grammatical rules;
    -- k: the locality measure;
    -- data: the language data given as input;
    -- data_sample: the generated data sample;
    -- fsm: the finite state machine that corresponds to the given grammar;
    -- tier: the list of tier symbols.
    """

    def __init__(self:PTSL, alphabet:Union[None,list]=None, grammar:Union[None,List[tuple]]=None, k:int=2,
                 data:Union[list,None]=None, edges=[">", "<"], tier:Union[None,list]=None) -> None:
        """ Initializes the NegTSL object. """
        
        super().__init__(alphabet, grammar, k, data, edges, tier)


    def learn(self:NTSL) -> None:
        """
        Extracts positive TSL grammar from the given data.

        Arguments:
        -- self.

        Results:
        -- self.grammar is being detected.
        """
        
        super().learn()
        self.grammar = self.opposite_polarity(self.grammar, self.tier, self.k)


    def scan(self:NTSL, string:str) -> bool:
        """
        Checks whether the given string can be generated by the grammar.

        Arguments:
        -- self;
        -- string: the string that needs to be evaluated.

        Returns:
        -- a boolean value depending on the well-formedness of the string
           with respect to the given grammar.
        """

        if not set(alphabetize([string])).issubset(set(self.alphabet)):
            return False
        tier_img = self.annotate_data(self.tier_image(string, self.tier), self.k)
        ngramized_string = self.ngramize_item(tier_img, self.k)
        for i in ngramized_string:
            if i in self.grammar:
                return False
        return True
        

    def change_polarity(self:NTSL) -> None:
        """
        Changes polarity of the grammar.

        Arguments:
        -- self.

        Results:
        -- self.grammar is being switched to the opposite;
        -- self.__class__ is changed to 'PTSL'.
        """

        if not self.tier:
            self.learn()
        self.grammar = self.opposite_polarity(self.grammar, self.tier, self.k)
        self.__class__ = PosTSL


    def fsmize(self:NTSL) -> None:
        """
        Function that builds FSM corresponding to the given grammar.

        Arguments:
        -- self.

        Results:
        -- self.fsm contains a finite states machine that corresponds to
                    the given grammar.
        """

        self.grammar = self.opposite_polarity(self.grammar, self.tier, self.k)
        super().fsmize()
        self.grammar = self.opposite_polarity(self.grammar, self.tier, self.k)


    def clean(self:NTSL) -> None:
        """
        Removes useless n-grams from the grammar. Useless ngrams are
        that can never be used in the language.

        Arguments:
        -- self.

        Results:
        -- self.fsm contains the FSM of the current grammar;
        -- self.grammar is being cleaned.
        """

        super().clean()
        self.grammar = self.opposite_polarity(self.grammar, self.tier, self.k)
